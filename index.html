<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Standalone Pi Monte Carlo Simulation</title>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <style>
body {
  font: 11px sans-serif;
}

.axis path,
.axis line {
  fill: none;
  stroke: #000;
  shape-rendering: crispEdges;
}

.dot {
  stroke: #000;
}

.tooltip {
  position: absolute;
  pointer-events: none;
  background: rgba(255,255,255,0.95);
  border: 1px solid #999;
  padding: 6px 8px;
  font-size: 12px;
  line-height: 1.4;
  border-radius: 4px;
  box-shadow: 0 2px 6px rgba(0,0,0,0.15);
  color: #111;
  max-width: 260px;
}

/* Overall three-column layout: sidebar, scatter, and two charts */
.layout {
  display: flex;
  gap: 20px;
  padding: 10px;
}
/* Sidebar column */
.sidebar {
  flex: 0 0 260px;
  padding: 10px;
  border-right: 1px solid #ccc;
}
/* Scatter and others columns */
.column {
  flex: 1;
  display: flex;
  flex-direction: column;
  gap: 20px;
}
/* Individual chart container stretches */
.chart-container {
  flex: 1;
}
/* Chart titles */
.chart-container h4 {
  text-align: center;
  margin: 0 0 5px;
  font-size: 1em;
}

/* Controls layout */
.controls {
  display: flex;
  align-items: center;
  gap: 10px;
  padding: 5px 0;
}

/* GPU controls timing display */
#gpuControls span {
  margin-left: 10px;
  font-weight: bold;
}

/* Legend styling */
.legend {
  display: flex;
  gap: 15px;
  padding: 5px 10px;
}
.legend-item {
  display: flex;
  align-items: center;
  gap: 5px;
}
.legend-box {
  width: 12px;
  height: 12px;
  border: 1px solid #000;
}
  </style>
</head>
<body>
  <div class="layout">
    <div class="sidebar">
      <h1>Monte Carlo π Simulation</h1>
      <label>No. Simulations:
        <input type="number" id="nValue" min="0" max="100000" step="100">
        <span id="nValue-value"></span>
      </label>
      <br>
      <label>Batch size:
        <input type="range" id="batchSize" min="1" max="1000" step="1" value="100">
        <span id="batchSize-value"></span>
      </label>
      <br>
      <label>Speed (ms):
        <input type="range" id="speedSlider" min="10" max="1000" step="10" value="100">
        <span id="speedValue"></span>
      </label>
      <br>
      <label>Method:
        <select id="methodSelect">
          <option value="quarter">Quarter Circle</option>
          <option value="quasi">Quasi‑MC</option>
        </select>
      </label>
      <br>
      <br>
      <button id="animateBtn">Animate</button>
      <button id="resetZoomBtn" title="Reset scatter zoom">Reset Zoom</button>
      <h3>π ≈ <span id="pi"></span></h3>
      <br>
      <div class="legend">
        <div class="legend-item"><span class="legend-box" style="background: blue"></span>Inside</div>
        <div class="legend-item"><span class="legend-box" style="background: red"></span>Outside</div>
      </div>
    </div>
    <div class="column">
      <div class="chart-container"><h4>Scatter Plot</h4><div id="scatter"></div></div>
    </div>
    <div class="column">
      <div class="chart-container"><h4>Convergence Plot</h4><div id="convergence"></div></div>
      <div class="chart-container"><h4>Std. Error Comparison</h4><div id="variance"></div></div>
    </div>
  </div>
  <script>
    // Sampling methods
    function quarter(N) {
      const points = [];
      const values = [];
      for (let i = 0; i < N; i++) {
        const x = Math.random();
        const y = Math.random();
        points.push([x, y]);
        values.push(x * x + y * y < 1 ? 1 : 0);
      }
      return { points, values };
    }
    function halton(index, base) {
      let result = 0, f = 1 / base, i = index;
      while (i > 0) {
        result += f * (i % base);
        i = Math.floor(i / base);
        f /= base;
      }
      return result;
    }
    function quasi(N) {
      const points = [];
      const values = [];
      for (let i = 1; i <= N; i++) {
        const x = halton(i, 2);
        const y = halton(i, 3);
        points.push([x, y]);
        values.push(x * x + y * y < 1 ? 1 : 0);
      }
      return { points, values };
    }
    const methods = { quarter, quasi };

    document.addEventListener('DOMContentLoaded', () => {
      const inputEl = document.getElementById('nValue');
      const methodEl = document.getElementById('methodSelect');
      const piEl = document.getElementById('pi');
      const nValEl = document.getElementById('nValue-value');
      const batchSlider = document.getElementById('batchSize');
      const batchLabel = document.getElementById('batchSize-value');
      const speedSlider = document.getElementById('speedSlider');
      const speedValue = document.getElementById('speedValue');
      batchLabel.textContent = batchSlider.value;
      speedValue.textContent = speedSlider.value;
      batchSlider.addEventListener('input', () => (batchLabel.textContent = batchSlider.value));
      speedSlider.addEventListener('input', () => (speedValue.textContent = speedSlider.value));
      // reflect the user-entered simulation count in the label
      nValEl.textContent = inputEl.value;
      inputEl.addEventListener('input', () => (nValEl.textContent = inputEl.value));

      // Chart setup (D3) and update/animate functions
      const margin = { top: 20, right: 15, bottom: 60, left: 60 };
      const width = 600 - margin.left - margin.right;
      const height = 600 - margin.top - margin.bottom;

      const xScale = d3.scaleLinear().domain([0, 1]).range([0, width]);
      const yScale = d3.scaleLinear().domain([0, 1]).range([height, 0]);

      const svg = d3
        .select('#scatter')
        .append('svg')
        .attr('width', width + margin.left + margin.right)
        .attr('height', height + margin.top + margin.bottom)
        .attr('class', 'chart')
        .attr('role', 'img')
        .attr('aria-label', 'Scatter plot of sampled points');
      const mainG = svg
        .append('g')
        .attr('transform', `translate(${margin.left},${margin.top})`);
      const xAxis = d3.axisBottom(xScale);
      const yAxis = d3.axisLeft(yScale);
      mainG.append('g').attr('class', 'x-axis').attr('transform', `translate(0,${height})`).call(xAxis);
      mainG.append('g').attr('class', 'y-axis').call(yAxis);
      const g = mainG.append('g');
      // Quarter-circle overlay (draw once)
      const quarterPts = d3.range(0, Math.PI / 2 + 0.001, Math.PI / 180).map((t) => [Math.cos(t), Math.sin(t)]);
      const circleLine = (xFn, yFn) => d3.line().x((d) => xFn(d[0])).y((d) => yFn(d[1]));
      mainG.append('path').datum(quarterPts).attr('class', 'quarter-circle').attr('d', circleLine(xScale, yScale)).style('stroke', '#333').style('fill', 'none');

      // Zoom behavior for scatter
      const zoom = d3.zoom().scaleExtent([1, 40]).on('zoom', zoomed);
      svg.call(zoom);
      function zoomed(event) {
        const t = event.transform;
        const zx = t.rescaleX(xScale);
        const zy = t.rescaleY(yScale);
        mainG.select('.x-axis').call(d3.axisBottom(zx));
        mainG.select('.y-axis').call(d3.axisLeft(zy));
        mainG.selectAll('circle').attr('cx', (d) => zx(d[0])).attr('cy', (d) => zy(d[1]));
        // update quarter-circle to transformed coordinates
        mainG.select('.quarter-circle').attr('d', circleLine(zx, zy)(quarterPts));
      }

      // tooltip div (shared)
      const tooltip = d3.select('body').append('div').attr('class', 'tooltip').style('opacity', 0);

      const convMargin = { top: 20, right: 20, bottom: 30, left: 50 };
      const convWidth = width - convMargin.left - convMargin.right;
      const convHeight = 200;
      const convSvgOuter = d3
        .select('#convergence')
        .append('svg')
        .attr('width', convWidth + convMargin.left + convMargin.right)
        .attr('height', convHeight + convMargin.top + convMargin.bottom)
        .attr('role', 'img')
        .attr('aria-label', 'Convergence chart');
      const convSvg = convSvgOuter.append('g').attr('transform', `translate(${convMargin.left},${convMargin.top})`);
      const xConv = d3.scaleLinear().range([0, convWidth]);
      const yConv = d3.scaleLinear().range([convHeight, 0]);
      const xAxisConv = d3.axisBottom(xConv);
      const yAxisConv = d3.axisLeft(yConv);
      convSvg.append('g').attr('class', 'x-axis').attr('transform', `translate(0,${convHeight})`);
      convSvg.append('g').attr('class', 'y-axis');
      // Convergence plot axis labels
      convSvg
        .append('text')
        .attr('class', 'axis-label')
        .attr('text-anchor', 'middle')
        .attr('x', convWidth / 2)
        .attr('y', convHeight + convMargin.bottom - 5)
        .text('Iteration');
      convSvg
        .append('text')
        .attr('class', 'axis-label')
        .attr('text-anchor', 'middle')
        .attr(
          'transform',
          `translate(${-convMargin.left + 15},${convHeight / 2}) rotate(-90)`
        )
        .text('π Estimate');
      const areaGen = d3.area().x((d, i) => xConv(i + 1));
      const lineGen = d3
        .line()
        .x((d, i) => xConv(i + 1))
        .y((d) => yConv(d));
      convSvg
        .append('path')
        .attr('class', 'area')
        .style('fill', 'lightsteelblue')
        .style('opacity', 0.3);
      convSvg
        .append('path')
        .attr('class', 'line')
        .style('fill', 'none')
        .style('stroke', 'steelblue')
        .style('stroke-width', 1.5);
      // π reference line
      convSvg.append('line').attr('class', 'pi-line').style('stroke', 'darkgreen').style('stroke-dasharray', '4,4');

      // latest convergence data (kept for zoom redraw)
      let latestCumEst = [];
      let latestLower = [];
      let latestUpper = [];

      /**
       * Dispatch to the selected sampling method.
       * @param {string} key - method key
       * @param {number} N - number of samples
       * @returns {{points: Array<[number,number]>, values: number[]}}
       */
      function simulate(key, N) {
        const fn = methods[key] || methods.quarter;
        return fn(N);
      }
      const varSvg = d3
        .select('#variance')
        .append('svg')
        .attr('width', convWidth + convMargin.left + convMargin.right)
        .attr('height', convHeight + convMargin.top + convMargin.bottom)
        .attr('role', 'img')
        .attr('aria-label', 'Standard error comparison')
        .append('g')
        .attr('transform', `translate(${convMargin.left},${convMargin.top})`);
      const methodKeys = Object.keys(methods);
      const xBar = d3.scaleBand().domain(methodKeys).range([0, convWidth]).padding(0.2);
      const yBar = d3.scaleLinear().range([convHeight, 0]);
      // Axes for variance (std. error) bar chart
      const xAxisBar = d3.axisBottom(xBar);
      const yAxisBar = d3.axisLeft(yBar);
      varSvg.append('g').attr('class', 'x-axis').attr('transform', `translate(0,${convHeight})`).call(xAxisBar);
      varSvg.append('g').attr('class', 'y-axis').call(yAxisBar);
      // Variance chart axis labels
      varSvg
        .append('text')
        .attr('class', 'axis-label')
        .attr('text-anchor', 'middle')
        .attr('x', convWidth / 2)
        .attr('y', convHeight + convMargin.bottom - 5)
        .text('Method');
      varSvg
        .append('text')
        .attr('class', 'axis-label')
        .attr('text-anchor', 'middle')
        .attr(
          'transform',
          `translate(${-convMargin.left + 15},${convHeight / 2}) rotate(-90)`
        )
        .text('Std. Error (π)');

      /**
       * Update scatter, convergence, and variance charts.
       * @param {number} N - number of samples (ignored if data provided)
       * @param {{points:Array,values:Array}} [data] - explicit sample data for streaming
       */
      function update(N, data) {
        const methodKey = methodEl.value;
        const points = data ? data.points : simulate(methodKey, N).points;
        const values = data ? data.values : simulate(methodKey, N).values;

        // If no data points, clear charts and exit to avoid NaN issues
        if (values.length === 0) {
          g.selectAll('circle').remove();
          convSvg.select('.area').datum([]).attr('d', '');
          convSvg.select('.line').datum([]).attr('d', '');
          varSvg.selectAll('.bar').remove();
          piEl.textContent = 'N/A';
          return;
        }

        // Scatter plot (only if 2D points available)
        const scatter = g.selectAll('circle').data(points);
        scatter.exit().remove();
        const enter = scatter
          .enter()
          .append('circle')
          .attr('cx', (d) => xScale(d[0]))
          .attr('cy', (d) => yScale(d[1]))
          .attr('r', 2)
          .style('fill', (d) => (d[0] * d[0] + d[1] * d[1] < 1 ? 'blue' : 'red'));
        // merge and set positions for all immediately (no transition)
        scatter.merge(enter).attr('cx', (d) => xScale(d[0])).attr('cy', (d) => yScale(d[1])).attr('r', 2).style('fill', (d) => (d[0] * d[0] + d[1] * d[1] < 1 ? 'blue' : 'red'));
        // tooltips
        g.selectAll('circle')
          .on('mouseover', function (event, d) {
            const inside = d[0] * d[0] + d[1] * d[1] < 1;
            tooltip.transition().duration(100).style('opacity', 0.95);
            tooltip.html(`x: ${d[0].toFixed(3)}<br/>y: ${d[1].toFixed(3)}<br/>${inside ? 'Inside' : 'Outside'}`)
              .style('left', event.pageX + 8 + 'px')
              .style('top', event.pageY + 8 + 'px');
          })
          .on('mousemove', function (event) {
            tooltip.style('left', event.pageX + 8 + 'px').style('top', event.pageY + 8 + 'px');
          })
          .on('mouseout', function () {
            tooltip.style('opacity', 0);
          });
        // attach reset zoom control (reset both scatter and convergence)
        const resetBtn = document.getElementById('resetZoomBtn');
        if (resetBtn) {
          resetBtn.onclick = () => {
            svg.transition().duration(200).call(zoom.transform, d3.zoomIdentity);
            convSvgOuter.transition().duration(200).call(zoomConv.transform, d3.zoomIdentity);
          };
        }
        // double-click on scatter svg to reset zoom
        svg.on('dblclick', () => svg.transition().duration(200).call(zoom.transform, d3.zoomIdentity));
        // double-click on convergence svg to reset its zoom
        convSvgOuter.on('dblclick', () => convSvgOuter.transition().duration(200).call(zoomConv.transform, d3.zoomIdentity));

        // Convergence tooltip: show nearest iteration values
        convSvgOuter.on('mousemove', function (event) {
          if (latestCumEst.length === 0) { tooltip.style('opacity', 0); return; }
          const pt = d3.pointer(event, convSvg.node());
          const t = d3.zoomTransform(convSvgOuter.node());
          const zx = t.rescaleX(xConv);
          const zy = t.rescaleY(yConv);
          const iter = Math.round(zx.invert(pt[0]));
          if (iter < 1 || iter > latestCumEst.length) { tooltip.style('opacity', 0); return; }
          const idx = iter - 1;
          const est = latestCumEst[idx];
          const low = latestLower[idx];
          const up = latestUpper[idx];
          tooltip.style('opacity', 1).html(
            `<strong>Iteration:</strong> ${iter}<br>` +
            `<strong>Estimate:</strong> ${est.toFixed(6)}<br>` +
            `<strong>Lower:</strong> ${low.toFixed(6)} &nbsp; <strong>Upper:</strong> ${up.toFixed(6)}`
          ).style('left', (event.pageX + 10) + 'px').style('top', (event.pageY + 10) + 'px');
        }).on('mouseleave', () => tooltip.style('opacity', 0));

        // Variance bars tooltip will be attached after bars are rendered below

        // Cumulative π estimates for convergence
        const cumEst = [];
        let sum = 0;
        for (let i = 0; i < values.length; i++) {
          sum += values[i];
          const avg = sum / (i + 1);
          // scale average to π (CPU methods all use quarter-circle sampling)
          cumEst.push(avg * 4);
        }
        // Compute error bands (±1σ/√i)
        const lower = [];
        const upper = [];
        let cumSum2 = 0;
        let sumSq = 0;
        for (let i = 0; i < values.length; i++) {
          cumSum2 += values[i];
          sumSq += values[i] * values[i];
          const meanY = cumSum2 / (i + 1);
          const varY = sumSq / (i + 1) - meanY * meanY;
          const se = Math.sqrt(varY / (i + 1));
          // convert standard error to π scale
          const delta = 4 * se;
          lower.push(cumEst[i] - delta);
          upper.push(cumEst[i] + delta);
        }
        // Update convergence chart axes & area/line (no transitions)
        const Nmax = Math.max(1, values.length);
        xConv.domain([1, Nmax]);
        const yMin = d3.min(lower.concat(cumEst));
        const yMax = d3.max(upper.concat(cumEst));
        yConv.domain([yMin * 0.95, yMax * 1.05]);
        convSvg.select('.x-axis').call(xAxisConv);
        convSvg.select('.y-axis').call(yAxisConv);
        // save latest arrays for zoom redraw
        latestCumEst = cumEst.slice();
        latestLower = lower.slice();
        latestUpper = upper.slice();
        convSvg.select('.area').datum(cumEst).attr('d', areaGen.y0((d, i) => yConv(lower[i])).y1((d, i) => yConv(upper[i])));
        convSvg.select('.line').datum(cumEst).attr('d', lineGen);
        // update π reference line
        convSvg.select('.pi-line').attr('x1', 0).attr('x2', convWidth).attr('y1', yConv(Math.PI)).attr('y2', yConv(Math.PI));

        // Display final approximation
        const final = cumEst.length > 0 ? cumEst[cumEst.length - 1] : 0;
        piEl.textContent = values.length > 0 ? final.toFixed(4) : 'N/A';

        // Update variance/comparison bar chart (standard error per method)
        const seData = methodKeys.map((key) => {
          const curN = values.length;
          const { values: vals } = simulate(key, curN);
          const sumVal = d3.sum(vals);
          const sumSqVal = d3.sum(vals.map((v) => v * v));
          const varY = sumSqVal / vals.length - (sumVal / vals.length) ** 2;
          return { method: key, se: 4 * Math.sqrt(varY / vals.length) };
        });
        const yMaxBar = d3.max(seData, (d) => d.se) || 0;
        yBar.domain([0, yMaxBar * 1.1]);
        varSvg.select('.y-axis').transition().duration(200).call(yAxisBar);
        const bars = varSvg.selectAll('.bar').data(seData, (d) => d.method);
        bars.exit().transition().duration(200).attr('height', 0).remove();
        bars
          .enter()
          .append('rect')
          .attr('class', 'bar')
          .attr('x', (d) => xBar(d.method))
          .attr('width', xBar.bandwidth())
          .style('fill', 'orange')
          .attr('y', convHeight)
          .attr('height', 0)
          .merge(bars)
          .transition()
          .duration(250)
          .attr('x', (d) => xBar(d.method))
          .attr('width', xBar.bandwidth())
          .attr('y', (d) => yBar(d.se))
          .attr('height', (d) => convHeight - yBar(d.se));
        // attach variance tooltips
        varSvg.selectAll('.bar')
          .on('mouseover', function (event, d) {
            tooltip.style('opacity', 1).html(`<strong>Method:</strong> ${d.method}<br><strong>Std. Error:</strong> ${d.se.toExponential(3)}`)
              .style('left', (event.pageX + 10) + 'px')
              .style('top', (event.pageY + 10) + 'px');
          })
          .on('mousemove', function (event) {
            tooltip.style('left', (event.pageX + 10) + 'px').style('top', (event.pageY + 10) + 'px');
          })
          .on('mouseout', function () {
            tooltip.style('opacity', 0);
          });
      }

      // Zoom behavior for convergence chart (pan/zoom for x and y)
      const zoomConv = d3.zoom().scaleExtent([1, 40]).on('zoom', zoomedConv);
      const convOuter = convSvgOuter; // alias
      convOuter.call(zoomConv);
      function zoomedConv(event) {
        const t = event.transform;
        const zx = t.rescaleX(xConv);
        const zy = t.rescaleY(yConv);
        convSvg.select('.x-axis').call(d3.axisBottom(zx));
        convSvg.select('.y-axis').call(d3.axisLeft(zy));
        if (latestCumEst.length > 0) {
          const areaZoom = d3.area().x((d, i) => zx(i + 1)).y0((d, i) => zy(latestLower[i])).y1((d, i) => zy(latestUpper[i]));
          const lineZoom = d3.line().x((d, i) => zx(i + 1)).y((d) => zy(d));
          convSvg.select('.area').attr('d', areaZoom(latestCumEst));
          convSvg.select('.line').attr('d', lineZoom(latestCumEst));
          convSvg.select('.pi-line').attr('x1', 0).attr('x2', convWidth).attr('y1', zy(Math.PI)).attr('y2', zy(Math.PI));
        }
      }

      // User must enter N and click Animate to run a single batch
      document.getElementById('animateBtn').addEventListener('click', () => {
        const total = +inputEl.value;
        if (total > 0) animate(total);
      });
  /**
   * Animate or statically plot sampling in batches with adjustable speed.
   * @param {number} total - total points to sample
   */
  let timer = null;
  function animate(total) {
    // clear any prior animation
    if (timer) clearInterval(timer);
    // reset charts
    g.selectAll('circle').remove();
    convSvg.select('.area').datum([]).attr('d', '');
    convSvg.select('.line').datum([]).attr('d', '');
    varSvg.selectAll('.bar').remove();
    piEl.textContent = '...';

    const methodKey = methodEl.value;
    const batchSize = +batchSlider.value;
    const delay = +speedSlider.value;
    // Pre-generate full sequence for quasi
    const full = methodKey === 'quasi' ? simulate(methodKey, total) : null;
    // If batchSize >= total, do one-off draw
    if (batchSize >= total) {
      const pts = full ? full.points : simulate(methodKey, total).points;
      const vals = full ? full.values : simulate(methodKey, total).values;
      update(undefined, { points: pts, values: vals });
      return;
    }
    let cumPointsLocal = [], cumValuesLocal = [], count = 0;
    timer = setInterval(() => {
      if (count >= total) {
        clearInterval(timer);
        timer = null;
        return;
      }
      let pts, vals;
      if (methodKey === 'quasi') {
        pts = full.points.slice(count, count + batchSize);
        vals = full.values.slice(count, count + batchSize);
      } else {
        const step = Math.min(batchSize, total - count);
        ({ points: pts, values: vals } = simulate(methodKey, step));
      }
      cumPointsLocal = cumPointsLocal.concat(pts);
      cumValuesLocal = cumValuesLocal.concat(vals);
      update(undefined, { points: cumPointsLocal, values: cumValuesLocal });
      count += pts.length;
    }, delay);
  }
    });
  </script>
</body>
</html>
