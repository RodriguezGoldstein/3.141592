<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Standalone Pi Monte Carlo Simulation</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/3.5.6/d3.min.js"></script>
  <style>
body {
  font: 11px sans-serif;
}

.axis path,
.axis line {
  fill: none;
  stroke: #000;
  shape-rendering: crispEdges;
}

.dot {
  stroke: #000;
}

.tooltip {
  position: absolute;
  width: 200px;
  height: 28px;
  pointer-events: none;
}

/* Overall three-column layout: sidebar, scatter, and two charts */
.layout {
  display: flex;
  gap: 20px;
  padding: 10px;
}
/* Sidebar column */
.sidebar {
  flex: 0 0 260px;
  padding: 10px;
  border-right: 1px solid #ccc;
}
/* Scatter and others columns */
.column {
  flex: 1;
  display: flex;
  flex-direction: column;
  gap: 20px;
}
/* Individual chart container stretches */
.chart-container {
  flex: 1;
}
/* Chart titles */
.chart-container h4 {
  text-align: center;
  margin: 0 0 5px;
  font-size: 1em;
}

/* Controls layout */
.controls {
  display: flex;
  align-items: center;
  gap: 10px;
  padding: 5px 0;
}

/* GPU controls timing display */
#gpuControls span {
  margin-left: 10px;
  font-weight: bold;
}

/* Legend styling */
.legend {
  display: flex;
  gap: 15px;
  padding: 5px 10px;
}
.legend-item {
  display: flex;
  align-items: center;
  gap: 5px;
}
.legend-box {
  width: 12px;
  height: 12px;
  border: 1px solid #000;
}
  </style>
</head>
<body>
  <div class="layout">
    <div class="sidebar">
      <h1>Monte Carlo π Simulation</h1>
      <label>Number of simulations:
        <input type="number" id="nValue" min="0" max="100000" step="100">
        <span id="nValue-value"></span>
      </label>
      <label>Batch size:
        <input type="range" id="batchSize" min="1" max="1000" step="1" value="100">
        <span id="batchSize-value"></span>
      </label>
      <label>Animation speed (ms):
        <input type="range" id="speedSlider" min="10" max="1000" step="10" value="100">
        <span id="speedValue"></span>
      </label>
      <label>Method:
        <select id="methodSelect">
          <option value="quarter">Quarter Circle</option>
          <option value="quasi">Quasi‑MC</option>
        </select>
      </label>
      <button id="animateBtn">Animate</button>
      <div class="legend">
        <div class="legend-item"><span class="legend-box" style="background: blue"></span>Inside</div>
        <div class="legend-item"><span class="legend-box" style="background: red"></span>Outside</div>
      </div>
      <h3>π ≈ <span id="pi"></span></h3>
    </div>
    <div class="column">
      <div class="chart-container"><h4>Scatter Plot</h4><div id="scatter"></div></div>
    </div>
    <div class="column">
      <div class="chart-container"><h4>Convergence Plot</h4><div id="convergence"></div></div>
      <div class="chart-container"><h4>Std. Error Comparison</h4><div id="variance"></div></div>
    </div>
  </div>
  <script>
    // Sampling methods
    function quarter(N) {
      const points = [];
      const values = [];
      for (let i = 0; i < N; i++) {
        const x = Math.random();
        const y = Math.random();
        points.push([x, y]);
        values.push(x * x + y * y < 1 ? 1 : 0);
      }
      return { points, values };
    }
    function halton(index, base) {
      let result = 0, f = 1 / base, i = index;
      while (i > 0) {
        result += f * (i % base);
        i = Math.floor(i / base);
        f /= base;
      }
      return result;
    }
    function quasi(N) {
      const points = [];
      const values = [];
      for (let i = 1; i <= N; i++) {
        const x = halton(i, 2);
        const y = halton(i, 3);
        points.push([x, y]);
        values.push(x * x + y * y < 1 ? 1 : 0);
      }
      return { points, values };
    }
    const methods = { quarter, quasi };

    document.addEventListener('DOMContentLoaded', () => {
      const inputEl = document.getElementById('nValue');
      const methodEl = document.getElementById('methodSelect');
      const piEl = document.getElementById('pi');
      const nValEl = document.getElementById('nValue-value');
      const batchSlider = document.getElementById('batchSize');
      const batchLabel = document.getElementById('batchSize-value');
      const speedSlider = document.getElementById('speedSlider');
      const speedValue = document.getElementById('speedValue');
      batchLabel.textContent = batchSlider.value;
      speedValue.textContent = speedSlider.value;
      batchSlider.addEventListener('input', () => (batchLabel.textContent = batchSlider.value));
      speedSlider.addEventListener('input', () => (speedValue.textContent = speedSlider.value));
      // reflect the user-entered simulation count in the label
      nValEl.textContent = inputEl.value;
      inputEl.addEventListener('input', () => (nValEl.textContent = inputEl.value));

      // Chart setup (D3) and update/animate functions
      const margin = { top: 20, right: 15, bottom: 60, left: 60 };
      const width = 600 - margin.left - margin.right;
      const height = 600 - margin.top - margin.bottom;

      const xScale = d3.scale.linear().domain([0, 1]).range([0, width]);
      const yScale = d3.scale.linear().domain([0, 1]).range([height, 0]);

      const svg = d3
        .select('#scatter')
        .append('svg')
        .attr('width', width + margin.left + margin.right)
        .attr('height', height + margin.top + margin.bottom)
        .attr('class', 'chart');
      const mainG = svg
        .append('g')
        .attr('transform', `translate(${margin.left},${margin.top})`);
      mainG
        .append('g')
        .attr('transform', `translate(0,${height})`)
        .call(d3.svg.axis().scale(xScale).orient('bottom'));
      mainG.append('g').call(d3.svg.axis().scale(yScale).orient('left'));
      const g = mainG.append('g');

      const convMargin = { top: 20, right: 20, bottom: 30, left: 50 };
      const convWidth = width - convMargin.left - convMargin.right;
      const convHeight = 200;
      const convSvg = d3
        .select('#convergence')
        .append('svg')
        .attr('width', convWidth + convMargin.left + convMargin.right)
        .attr('height', convHeight + convMargin.top + convMargin.bottom)
        .append('g')
        .attr('transform', `translate(${convMargin.left},${convMargin.top})`);
      const xConv = d3.scale.linear().range([0, convWidth]);
      const yConv = d3.scale.linear().range([convHeight, 0]);
      const xAxisConv = d3.svg.axis().scale(xConv).orient('bottom');
      const yAxisConv = d3.svg.axis().scale(yConv).orient('left');
      convSvg.append('g').attr('class', 'x-axis').attr('transform', `translate(0,${convHeight})`);
      convSvg.append('g').attr('class', 'y-axis');
      // Convergence plot axis labels
      convSvg
        .append('text')
        .attr('class', 'axis-label')
        .attr('text-anchor', 'middle')
        .attr('x', convWidth / 2)
        .attr('y', convHeight + convMargin.bottom - 5)
        .text('Iteration');
      convSvg
        .append('text')
        .attr('class', 'axis-label')
        .attr('text-anchor', 'middle')
        .attr(
          'transform',
          `translate(${-convMargin.left + 15},${convHeight / 2}) rotate(-90)`
        )
        .text('π Estimate');
      const areaGen = d3.svg.area().x((d, i) => xConv(i + 1));
      const lineGen = d3.svg
        .line()
        .x((d, i) => xConv(i + 1))
        .y((d) => yConv(d));
      convSvg
        .append('path')
        .attr('class', 'area')
        .style('fill', 'lightsteelblue')
        .style('opacity', 0.3);
      convSvg
        .append('path')
        .attr('class', 'line')
        .style('fill', 'none')
        .style('stroke', 'steelblue');

      /**
       * Dispatch to the selected sampling method.
       * @param {string} key - method key
       * @param {number} N - number of samples
       * @returns {{points: Array<[number,number]>, values: number[]}}
       */
      function simulate(key, N) {
        const fn = methods[key] || methods.quarter;
        return fn(N);
      }
      const varSvg = d3
        .select('#variance')
        .append('svg')
        .attr('width', convWidth + convMargin.left + convMargin.right)
        .attr('height', convHeight + convMargin.top + convMargin.bottom)
        .append('g')
        .attr('transform', `translate(${convMargin.left},${convMargin.top})`);
      const methodKeys = Object.keys(methods);
      const xBar = d3.scale.ordinal().domain(methodKeys).rangeBands([0, convWidth], 0.2);
      const yBar = d3.scale.linear().range([convHeight, 0]);
      varSvg.append('g').attr('class', 'x-axis').attr('transform', `translate(0,${convHeight})`).call(d3.svg.axis().scale(xBar).orient('bottom'));
      varSvg.append('g').attr('class', 'y-axis');

      /**
       * Update scatter, convergence, and variance charts.
       * @param {number} N - number of samples (ignored if data provided)
       * @param {{points:Array,values:Array}} [data] - explicit sample data for streaming
       */
      function update(N, data) {
        const methodKey = methodEl.value;
        const points = data ? data.points : simulate(methodKey, N).points;
        const values = data ? data.values : simulate(methodKey, N).values;

        // If no data points, clear charts and exit to avoid NaN issues
        if (values.length === 0) {
          g.selectAll('circle').remove();
          convSvg.select('.area').datum([]).attr('d', '');
          convSvg.select('.line').datum([]).attr('d', '');
          varSvg.selectAll('.bar').remove();
          piEl.textContent = 'N/A';
          return;
        }

        // Scatter plot (only if 2D points available)
        const scatter = g.selectAll('circle').data(points);
        scatter.exit().remove();
        scatter.enter().append('circle').attr('r', 2);
        scatter
          .attr('cx', (d) => xScale(d[0]))
          .attr('cy', (d) => yScale(d[1]))
          .style('fill', (d) => (d[0] * d[0] + d[1] * d[1] < 1 ? 'blue' : 'red'));

        // Cumulative π estimates for convergence
        const cumEst = [];
        let sum = 0;
        for (let i = 0; i < values.length; i++) {
          sum += values[i];
          const avg = sum / (i + 1);
          // scale average to π (CPU methods all use quarter-circle sampling)
          cumEst.push(avg * 4);
        }
        // Compute error bands (±1σ/√i)
        const lower = [];
        const upper = [];
        let cumSum2 = 0;
        let sumSq = 0;
        for (let i = 0; i < values.length; i++) {
          cumSum2 += values[i];
          sumSq += values[i] * values[i];
          const meanY = cumSum2 / (i + 1);
          const varY = sumSq / (i + 1) - meanY * meanY;
          const se = Math.sqrt(varY / (i + 1));
          // convert standard error to π scale
          const delta = 4 * se;
          lower.push(cumEst[i] - delta);
          upper.push(cumEst[i] + delta);
        }
        // Update convergence chart axes & area/line
        const Nmax = Math.max(1, values.length);
        xConv.domain([1, Nmax]);
        const yMin = d3.min(lower.concat(cumEst));
        const yMax = d3.max(upper.concat(cumEst));
        yConv.domain([yMin * 0.95, yMax * 1.05]);
        convSvg.select('.x-axis').call(xAxisConv);
        convSvg.select('.y-axis').call(yAxisConv);
        convSvg
          .select('.area')
          .datum(cumEst)
          .attr(
            'd',
            areaGen.y0((d, i) => yConv(lower[i])).y1((d, i) => yConv(upper[i]))
          );
        convSvg.select('.line').datum(cumEst).attr('d', lineGen);

        // Display final approximation
        const final = cumEst.length > 0 ? cumEst[cumEst.length - 1] : 0;
        piEl.textContent = values.length > 0 ? final.toFixed(4) : 'N/A';

        // Update variance/comparison bar chart (standard error per method)
        const seData = methodKeys.map((key) => {
          const curN = values.length;
          const { values: vals } = simulate(key, curN);
          const sumVal = d3.sum(vals);
          const sumSqVal = d3.sum(vals.map((v) => v * v));
          const varY = sumSqVal / vals.length - (sumVal / vals.length) ** 2;
          return { method: key, se: 4 * Math.sqrt(varY / vals.length) };
        });
        const yMaxBar = d3.max(seData, (d) => d.se) || 0;
        yBar.domain([0, yMaxBar * 1.1]);
        varSvg.select('.y-axis').call(yAxisBar);
        const bars = varSvg.selectAll('.bar').data(seData);
        bars.exit().remove();
        bars
          .enter()
          .append('rect')
          .attr('class', 'bar')
          .attr('x', (d) => xBar(d.method))
          .attr('width', xBar.rangeBand())
          .style('fill', 'orange');
        bars
          .attr('y', (d) => yBar(d.se))
          .attr('height', (d) => convHeight - yBar(d.se));
      }

      // User must enter N and click Animate to run a single batch
      document.getElementById('animateBtn').addEventListener('click', () => {
        const total = +inputEl.value;
        if (total > 0) animate(total);
      });
  /**
   * Animate or statically plot sampling in batches with adjustable speed.
   * @param {number} total - total points to sample
   */
  let timer = null;
  function animate(total) {
    // clear any prior animation
    if (timer) clearInterval(timer);
    // reset charts
    g.selectAll('circle').remove();
    convSvg.select('.area').datum([]).attr('d', '');
    convSvg.select('.line').datum([]).attr('d', '');
    varSvg.selectAll('.bar').remove();
    piEl.textContent = '...';

    const methodKey = methodEl.value;
    const batchSize = +batchSlider.value;
    const delay = +speedSlider.value;
    // Pre-generate full sequence for quasi
    const full = methodKey === 'quasi' ? simulate(methodKey, total) : null;
    // If batchSize >= total, do one-off draw
    if (batchSize >= total) {
      const pts = full ? full.points : simulate(methodKey, total).points;
      const vals = full ? full.values : simulate(methodKey, total).values;
      update(undefined, { points: pts, values: vals });
      return;
    }
    let cumPointsLocal = [], cumValuesLocal = [], count = 0;
    timer = setInterval(() => {
      if (count >= total) {
        clearInterval(timer);
        timer = null;
        return;
      }
      let pts, vals;
      if (methodKey === 'quasi') {
        pts = full.points.slice(count, count + batchSize);
        vals = full.values.slice(count, count + batchSize);
      } else {
        const step = Math.min(batchSize, total - count);
        ({ points: pts, values: vals } = simulate(methodKey, step));
      }
      cumPointsLocal = cumPointsLocal.concat(pts);
      cumValuesLocal = cumValuesLocal.concat(vals);
      update(undefined, { points: cumPointsLocal, values: cumValuesLocal });
      count += pts.length;
    }, delay);
  }
    });
  </script>
</body>
</html>
